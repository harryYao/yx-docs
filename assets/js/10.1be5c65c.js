(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{355:function(a,e,s){"use strict";s.r(e);var l=s(41),t=Object(l.a)({},(function(){var a=this,e=a.$createElement,s=a._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"js基础类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js基础类型"}},[a._v("#")]),a._v(" js基础类型")]),a._v(" "),s("p",[a._v("ECMAScript中有5中简单数据类型（也称为基本数据类型）: Undefined、Null、Boolean、Number和String。\n还有1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。")]),a._v(" "),s("p",[a._v("其中Undefined、Null、Boolean、Number都属于基本类型。Object、Array和Function则属于引用类型，String有些特殊，具体的会在下面展开分析。\nstring类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本类型相似的不可变引用类型")]),a._v(" "),s("p",[a._v("Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('alert(typeof new String("jwy"));//"object"\nvar author = "Tom";\nalert(typeof name);//"string"\n')])])]),s("h3",{attrs:{id:"undefined"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#undefined"}},[a._v("#")]),a._v(" undefined")]),a._v(" "),s("p",[a._v("变量声明了但是没赋值 解析器会给一个默认值 就是undefined")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var a;\nif (a === undefined) {\n  console.log('a is undefined')\n} else {\n  console.log('a is not defined')\n}\n\ntypeof a; // undefined\n")])])]),s("ol",[s("li",[a._v("变量没赋值")]),a._v(" "),s("li",[a._v("数组中某项没赋值")]),a._v(" "),s("li",[a._v("函数的参数没赋值")]),a._v(" "),s("li",[a._v("函数没有返回值")]),a._v(" "),s("li",[a._v("对象某个属性没有赋值\n以上情况都为undefined.")])]),a._v(" "),s("h3",{attrs:{id:"null"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#null"}},[a._v("#")]),a._v(" Null")]),a._v(" "),s("p",[a._v("本质上就是一个特殊值，表示“没有”")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var a = null;\ntypeof a; // object\n")])])]),s("blockquote",[s("p",[a._v("只把它当作object的一种特殊值，为了兼容以前的代码，后来就没法修改了。\n这并不是说null就属于对象")])]),a._v(" "),s("blockquote",[s("p",[a._v("2015年, ES6草案时，也曾将 null 的数据类型修改为了 null, 但是因为兼容性问题，后来又改回了object；")])]),a._v(" "),s("ul",[s("li",[a._v("获取一个不存在的对象时，值为null,如获取一个不存在的DOM对象")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var d = document.getElementById('shdyfajfasf');\nd; // null\n")])])]),s("ul",[s("li",[a._v("null是一个表示”无”的对象，转为数值时为0；")]),a._v(" "),s("li",[a._v("undefined是一个表示”无”的原始值，转为数值时为NaN")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var n = Number(null);\nn; // 0\nvar m = Number(undefined);\nm; // NaN\n")])])]),s("h3",{attrs:{id:"boolean"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#boolean"}},[a._v("#")]),a._v(" boolean")]),a._v(" "),s("p",[a._v("使用Boolean(value)方法可以强制转换任意值为boolean类型,除了以下六个值，其他都是自动转为true：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Boolean(undefined) // false\nBoolean(null) // false\nBoolean(-0) // false\nBoolean(0) // false\nBoolean(NaN) // false\nBoolean('') // false\n")])])]),s("p",[a._v("所有对象的布尔值都是true，甚至连false对应的布尔对象也是true。\n请注意，空对象{}和空数组[]也会被转成true。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Boolean(new Boolean(false))// Boolean对象会转成true\nBoolean([]) // 空数组会转成true\nBoolean({}) // 空对象会转成true\n")])])]),s("p",[a._v("&& 表达式从第一个开始,遇到值为false的表达式,则返回表达式本身,否则返回最后一个表达式")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var obj = new Boolean(false);\nconsole.log(obj && true);//true\nconsole.log(true && obj);//Boolean {false}\n")])])]),s("p",[a._v("因此,第二个console实际上打印的是obj对象的值")]),a._v(" "),s("h3",{attrs:{id:"string"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[a._v("#")]),a._v(" String")]),a._v(" "),s("h3",{attrs:{id:"number"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#number"}},[a._v("#")]),a._v(" Number")]),a._v(" "),s("h4",{attrs:{id:"nan"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nan"}},[a._v("#")]),a._v(" NaN")]),a._v(" "),s("p",[a._v("不是一个数，但是属于数值类型, NaN和任何数操作都为NaN, 和任何值都不相等，包括他本身")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("typeof NaN; // number\nNaN === NaN; // false\n")])])]),s("ul",[s("li",[a._v("isNaN 函数来判断是否是NaN")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("console.log( isNaN(NaN ) // true \nconsole.log( isNaN(10 ) // false\nconsole.log( isNaN('10') // false\nconsole.log( isNaN('blue') // true\nconsole.log(isNaN( true )) // false (true会被转换成1)\n")])])]),s("h4",{attrs:{id:"数值转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数值转换"}},[a._v("#")]),a._v(" 数值转换")]),a._v(" "),s("p",[a._v("把非数值值转换为数值")]),a._v(" "),s("ul",[s("li",[a._v("Number()")]),a._v(" "),s("li",[a._v("parseInt() 取整, 将一个字符串转换成x进制的整数。")]),a._v(" "),s("li",[a._v("parseFloat() 浮点数")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('Number(true) // 1\nNumber(false) // 0\nNumber(null) // 0\nNumber(\'\') // 0\nNumber(\' \') // 0\nNumber(undefined) // NaN\nNumber([]) // 0\nNumber([2]) // 2\nNumber([2, 3]) // NaN\nNumber(0xf) // 15 \n\nparseInt("123abc") // 123\nparseInt("") // NaN\nparseInt("12.5px") // 12\nparseInt("0xA") // 10 (16进制)\nparseInt("0xf") // 15 (16进制)\nparseInt("070") // 70\nparseInt("70") // 70\n\nparseFloat("3.14") // 3.14\nparseFloat("-3.14") //-3.14\nparseFloat("+3.14") //3.14\nparseFloat("0003.14") // 3.14\nparseFloat(" 3.14 ") // 3.14\nparseFloat("3.14abc") // 3.14\nparseFloat("3.14.5678") // 3.14\nparseFloat("abc3.14") // NaN\nparseFloat("abc123") // NaN\nparseFloat("123abc") // 123\n')])])]),s("p",[a._v("为什么Number和parseInt/parseFloat计算结果不一样呢？")]),a._v(" "),s("ul",[s("li",[a._v("Number转换规则是浏览器底层渲染规则，是浏览器的一个非常重要的方法，parseInt/parseFloat是一个单独方法的规则，就是用来处理字符串的。")]),a._v(" "),s("li",[a._v("Number走的是最底层的机制，遇到其他类型，底层机制会告诉我们哪个类型跟哪个类型应该怎么转换，这是底层机制已经规定好的，比如遇到布尔值，true转为1，false转为0")]),a._v(" "),s("li",[a._v("parseInt和parseFloat是额外提供的方法，就是浏览器提供的方法，它们的源码处理机制很简单，会先把传入的参数转换为字符串，然后在从左到右查找数字有效字符。")])]),a._v(" "),s("h3",{attrs:{id:"es6-新增的基本类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-新增的基本类型"}},[a._v("#")]),a._v(" ES6 新增的基本类型")]),a._v(" "),s("h3",{attrs:{id:"symbol"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[a._v("#")]),a._v(" Symbol")]),a._v(" "),s("p",[a._v("ES6新加入了一种原始数据类型Symbol，表示独一无二的值")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('let s = Symbol();\ntypeof s; // "symbol"\n')])])]),s("p",[a._v("Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象，所以不能添加属性。基本上，它是一种类似于字符串的原始数据类型。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('var s1 = Symbol("foo");\nvar s2 = Symbol("foo");\nconsole.log(s1 == s2); // false\nconsole.log(s1 === s2); // false\n')])])]),s("h4",{attrs:{id:"作为属性名的symbol"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作为属性名的symbol"}},[a._v("#")]),a._v(" 作为属性名的Symbol")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var symbol = Symbol();\n// 第一种写法\nvar a = {};\na[symbol] = 'Hello!';\n\n// 第二种写法\nvar b = {\n  [symbol]: 'Hello!'\n};\n\n// 第三种写法\nvar c = {};\nObject.defineProperty(a, symbol, { value: 'Hello!' });\n\n\n// 以上写法都得到同样结果\nconsole.log(a[symbol]); // \"Hello!\"\nconsole.log(b[symbol]); // \"Hello!\"\nconsole.log(c[symbol]); // \"Hello!\"\n")])])]),s("ul",[s("li",[a._v("在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。")])]),a._v(" "),s("p",[a._v("Symbol作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。"),s("br"),a._v("\n但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n \nobj[a] = 'Hello';\nobj[b] = 'World';\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\nconsole.log(objectSymbols);\n// [Symbol(a), Symbol(b)]\n")])])]),s("h4",{attrs:{id:"symbol-for"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#symbol-for"}},[a._v("#")]),a._v(" Symbol.for()")]),a._v(" "),s("p",[a._v("使用给定的key搜索现有符号，如果找到则返回符号。否则将得到一个新的使用给定的key在全局符号注册表中创建的符号。")]),a._v(" "),s("p",[a._v("有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var s1 = Symbol.for('foo');\nvar s2 = Symbol.for('foo');\nconsole.log(s1 === s2); // true\n")])])]),s("p",[a._v("Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。")]),a._v(" "),s("h4",{attrs:{id:"symbol-keyfor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#symbol-keyfor"}},[a._v("#")]),a._v(" Symbol.keyFor()")]),a._v(" "),s("p",[a._v("Symbol.keyFor方法返回一个已登记的Symbol类型值的key。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('var s1 = Symbol.for("foo");\nSymbol.keyFor(s1) // "foo"\n \nvar s2 = Symbol("foo");\nSymbol.keyFor(s2) // undefined\n')])])])])}),[],!1,null,null,null);e.default=t.exports}}]);