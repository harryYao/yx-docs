(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{357:function(o,t,e){"use strict";e.r(t);var r=e(41),n=Object(r.a)({},(function(){var o=this,t=o.$createElement,e=o._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("h2",{attrs:{id:"原型-prototype"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型-prototype"}},[o._v("#")]),o._v(" 原型 prototype")]),o._v(" "),e("p",[o._v("每个函数都有一个prototype属性，这个属性指向函数的原型(prototype)对象")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("function Person(age) {\n    this.age = age       \n}\nPerson.prototype = {\n  name: 'kavin',\n  say() {\n    console.log('Hi!');\n  }\n}\nvar person1 = new Person()\nvar person2 = new Person()\nconsole.log(person1.name)   // kavin\nconsole.log(person2.say())  // Hi!\n")])])]),e("h2",{attrs:{id:"proto"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proto"}},[o._v("#")]),o._v(" "),e("strong",[o._v("proto")])]),o._v(" "),e("p",[o._v("这是每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("var person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n")])])]),e("h2",{attrs:{id:"constructor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[o._v("#")]),o._v(" constructor")]),o._v(" "),e("p",[o._v("每个原型都有一个constructor属性，指向该关联的构造函数。"),e("br"),o._v("\n前提是没有单独去设置 Person.prototype")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("function Person() {\n}\nvar person = new Person();\nconsole.log(Person === Person.prototype.constructor)  //true\n// Object.getPrototypeOf 可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n")])])]),e("ul",[e("li",[o._v("补充说明：")])]),o._v(" "),e("p",[o._v("绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 "),e("code",[o._v("obj.__proto__")]),o._v(" 时，可以理解成返回了 Object.getPrototypeOf(obj)。")]),o._v(" "),e("h2",{attrs:{id:"原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[o._v("#")]),o._v(" 原型链")]),o._v(" "),e("p",[o._v("当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。")]),o._v(" "),e("p",[o._v("我们最终会找到Object.prototype，")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("console.log(Object.prototype.__proto__ === null) // true\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("  function Person() {\n  }\n  console.log(Person);  // Person() {}\n  console.log(Person.prototype.constructor);    // Person() {}\n  console.log(Person.prototype.__proto__);      // Object.prototype\n  console.log(Person.prototype.__proto__.__proto__);    // null\n  console.log(Person.prototype.__proto__.constructor);  // Object()\n  console.log(Person.prototype.__proto__ === Object.prototype); // true\n\n  var person = new Person();\n  console.log(person);  // Person {}\n  console.log(person.__proto__ === Person.prototype);       // true\n  console.log(person.__proto__.constructor === Person);     // true\n  console.log(person.__proto__.__proto__ === Object.prototype);   // true\n  console.log(person.__proto__.__proto__.__proto__ === null);     // true\n  console.log(person.__proto__.__proto__.constructor === Object); // true\n  console.log(person.__proto__.__proto__ === Object.prototype);   //true\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);