(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{356:function(e,a,l){"use strict";l.r(a);var s=l(41),o=Object(s.a)({},(function(){var e=this,a=e.$createElement,l=e._self._c||a;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h2",{attrs:{id:"js基础类型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#js基础类型"}},[e._v("#")]),e._v(" js基础类型")]),e._v(" "),l("p",[e._v("ECMAScript中有5中简单数据类型（也称为基本数据类型）: Undefined、Null、Boolean、Number和String。\n还有1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。")]),e._v(" "),l("p",[e._v("其中Undefined、Null、Boolean、Number都属于基本类型。Object、Array和Function则属于引用类型，String有些特殊，具体的会在下面展开分析。\nstring类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本类型相似的不可变引用类型")]),e._v(" "),l("p",[e._v("Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v('alert(typeof new String("jwy"));//"object"\nvar author = "Tom";\nalert(typeof name);//"string"\n')])])]),l("h3",{attrs:{id:"undefined"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#undefined"}},[e._v("#")]),e._v(" undefined")]),e._v(" "),l("p",[e._v("变量声明了但是没赋值 解析器会给一个默认值 就是undefined")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("var a;\nif (a === undefined) {\n  console.log('a is undefined')\n} else {\n  console.log('a is not defined')\n}\n\ntypeof a; // undefined\n")])])]),l("ol",[l("li",[e._v("变量没赋值")]),e._v(" "),l("li",[e._v("数组中某项没赋值")]),e._v(" "),l("li",[e._v("函数的参数没赋值")]),e._v(" "),l("li",[e._v("函数没有返回值")]),e._v(" "),l("li",[e._v("对象某个属性没有赋值\n以上情况都为undefined.")])]),e._v(" "),l("h3",{attrs:{id:"null"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#null"}},[e._v("#")]),e._v(" Null")]),e._v(" "),l("p",[e._v("本质上就是一个特殊值，表示“没有”")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("var a = null;\ntypeof a; // object\n")])])]),l("blockquote",[l("p",[e._v("只把它当作object的一种特殊值，为了兼容以前的代码，后来就没法修改了。\n这并不是说null就属于对象")])]),e._v(" "),l("blockquote",[l("p",[e._v("2015年, ES6草案时，也曾将 null 的数据类型修改为了 null, 但是因为兼容性问题，后来又改回了object；")])]),e._v(" "),l("ul",[l("li",[e._v("获取一个不存在的对象时，值为null,如获取一个不存在的DOM对象")])]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("var d = document.getElementById('shdyfajfasf');\nd; // null\n")])])]),l("ul",[l("li",[e._v("null是一个表示”无”的对象，转为数值时为0；")]),e._v(" "),l("li",[e._v("undefined是一个表示”无”的原始值，转为数值时为NaN")])]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("var n = Number(null);\nn; // 0\nvar m = Number(undefined);\nm; // NaN\n")])])]),l("h3",{attrs:{id:"boolean"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#boolean"}},[e._v("#")]),e._v(" boolean")]),e._v(" "),l("p",[e._v("使用Boolean(value)方法可以强制转换任意值为boolean类型,除了以下六个值，其他都是自动转为true：")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("Boolean(undefined) // false\nBoolean(null) // false\nBoolean(-0) // false\nBoolean(0) // false\nBoolean(NaN) // false\nBoolean('') // false\n")])])]),l("p",[e._v("所有对象的布尔值都是true，甚至连false对应的布尔对象也是true。\n请注意，空对象{}和空数组[]也会被转成true。")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("Boolean(new Boolean(false))// Boolean对象会转成true\nBoolean([]) // 空数组会转成true\nBoolean({}) // 空对象会转成true\n")])])]),l("p",[e._v("&& 表达式从第一个开始,遇到值为false的表达式,则返回表达式本身,否则返回最后一个表达式")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("var obj = new Boolean(false);\nconsole.log(obj && true);//true\nconsole.log(true && obj);//Boolean {false}\n")])])]),l("p",[e._v("因此,第二个console实际上打印的是obj对象的值")]),e._v(" "),l("h3",{attrs:{id:"es6-新增的基本类型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#es6-新增的基本类型"}},[e._v("#")]),e._v(" ES6 新增的基本类型")]),e._v(" "),l("h3",{attrs:{id:"symbol"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[e._v("#")]),e._v(" Symbol")]),e._v(" "),l("p",[e._v("ES6新加入了一种原始数据类型Symbol，表示独一无二的值")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v('let s = Symbol();\ntypeof s; // "symbol"\n')])])]),l("p",[e._v("Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象，所以不能添加属性。基本上，它是一种类似于字符串的原始数据类型。")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v('var s1 = Symbol("foo");\nvar s2 = Symbol("foo");\nconsole.log(s1 == s2); // false\nconsole.log(s1 === s2); // false\n')])])]),l("h4",{attrs:{id:"作为属性名的symbol"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#作为属性名的symbol"}},[e._v("#")]),e._v(" 作为属性名的Symbol")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("var symbol = Symbol();\n// 第一种写法\nvar a = {};\na[symbol] = 'Hello!';\n\n// 第二种写法\nvar b = {\n  [symbol]: 'Hello!'\n};\n\n// 第三种写法\nvar c = {};\nObject.defineProperty(a, symbol, { value: 'Hello!' });\n\n\n// 以上写法都得到同样结果\nconsole.log(a[symbol]); // \"Hello!\"\nconsole.log(b[symbol]); // \"Hello!\"\nconsole.log(c[symbol]); // \"Hello!\"\n")])])]),l("ul",[l("li",[e._v("在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。")])]),e._v(" "),l("p",[e._v("Symbol作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。"),l("br"),e._v("\n但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("var obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n \nobj[a] = 'Hello';\nobj[b] = 'World';\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\nconsole.log(objectSymbols);\n// [Symbol(a), Symbol(b)]\n")])])]),l("h4",{attrs:{id:"symbol-for"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#symbol-for"}},[e._v("#")]),e._v(" Symbol.for()")]),e._v(" "),l("p",[e._v("使用给定的key搜索现有符号，如果找到则返回符号。否则将得到一个新的使用给定的key在全局符号注册表中创建的符号。")]),e._v(" "),l("p",[e._v("有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("var s1 = Symbol.for('foo');\nvar s2 = Symbol.for('foo');\nconsole.log(s1 === s2); // true\n")])])]),l("p",[e._v("Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。")]),e._v(" "),l("h4",{attrs:{id:"symbol-keyfor"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#symbol-keyfor"}},[e._v("#")]),e._v(" Symbol.keyFor()")]),e._v(" "),l("p",[e._v("Symbol.keyFor方法返回一个已登记的Symbol类型值的key。")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v('var s1 = Symbol.for("foo");\nSymbol.keyFor(s1) // "foo"\n \nvar s2 = Symbol("foo");\nSymbol.keyFor(s2) // undefined\n')])])])])}),[],!1,null,null,null);a.default=o.exports}}]);