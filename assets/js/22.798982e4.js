(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{368:function(v,_,t){"use strict";t.r(_);var T=t(41),l=Object(T.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"https介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https介绍"}},[v._v("#")]),v._v(" HTTPS介绍")]),v._v(" "),t("p",[v._v("HTTP 协议中没有加密机制,但可以通 过和 SSL(Secure Socket Layer, 安全套接层 )或\nTLS(Transport Layer Security, 安全层传输协议)的组合使用,加密 HTTP 的通信内容。属于通信加密，即在整个通信线路中加密。")]),v._v(" "),t("p",[v._v("HTTP + 加密 + 认证 + 完整性保护 = HTTPS（HTTP Secure ）")]),v._v(" "),t("ol",[t("li",[v._v("浏览器将自己支持的一套加密规则发送给网站。\n服务器获得浏览器公钥")]),v._v(" "),t("li",[v._v("网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 浏览器获得服务器公钥")]),v._v(" "),t("li",[v._v("获得网站证书之后浏览器要做以下工作：\n(a). 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。\n(b). 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码（接下来通信的密钥），并用证书中提供的公钥加密（共享密钥加密）。\n(c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 浏览器验证 -> 随机密码 服务器的公钥加密 -> 通信的密钥 通信的密钥 -> 服务器")]),v._v(" "),t("li",[v._v("网站接收浏览器发来的数据之后要做以下的操作：\n(a). 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。\n(b). 使用密码加密一段握手消息，发送给浏览器。\n服务器用自己的私钥解出随机密码 -> 用密码解密握手消息（共享密钥通信）-> 验证HASH与浏览器是否一致（验证浏览器）\nHTTPS的不足")]),v._v(" "),t("li",[v._v("加密解密过程复杂，导致访问速度慢")]),v._v(" "),t("li",[v._v("加密需要认向证机构付费")]),v._v(" "),t("li",[v._v("整个页面的请求都要使用HTTPS")])]),v._v(" "),t("hr"),v._v(" "),t("p",[v._v("一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("客户端向服务器发起HTTPS请求，连接到服务器的443端口")])]),v._v(" "),t("li",[t("p",[v._v("服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。")])]),v._v(" "),t("li",[t("p",[v._v("服务器将自己的公钥发送给客户端。")])]),v._v(" "),t("li",[t("p",[v._v("客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。")])]),v._v(" "),t("li",[t("p",[v._v("客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。")])]),v._v(" "),t("li",[t("p",[v._v("服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。")])]),v._v(" "),t("li",[t("p",[v._v("然后服务器将加密后的密文发送给客户端。")])]),v._v(" "),t("li",[t("p",[v._v("客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。")])])]),v._v(" "),t("h3",{attrs:{id:"http的不足"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http的不足"}},[v._v("#")]),v._v(" HTTP的不足")]),v._v(" "),t("ul",[t("li",[v._v("通信使用明文(不加密),内容可能会被窃听")]),v._v(" "),t("li",[v._v("不验证通信方的身份,因此有可能遭遇伪装")]),v._v(" "),t("li",[v._v("无法证明报文的完整性,所以有可能已遭篡改")])]),v._v(" "),t("p",[v._v("https://zhuanlan.zhihu.com/p/45173862")])])}),[],!1,null,null,null);_.default=l.exports}}]);